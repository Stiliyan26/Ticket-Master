---
description: Error handling strategy - when to throw what, exception hierarchy.
alwaysApply: false
---

# Error Handling Strategy

## Exception Categories

```
Errors
├── Business Errors (expected, recoverable)
│   ├── Validation errors (bad input)
│   ├── Not found errors (missing resource)
│   └── Conflict errors (state violation)
│
└── Technical Errors (unexpected, log & alert)
    ├── Database connection failures
    ├── External service failures
    └── Unexpected exceptions
```

---

## When to Throw Which Exception

| Scenario                     | Exception                      | HTTP Status |
| ---------------------------- | ------------------------------ | ----------- |
| Resource not found           | `NotFoundException`            | 404         |
| Invalid input / validation   | `BadRequestException`          | 400         |
| Duplicate / unique violation | `ConflictException`            | 409         |
| Business rule violation      | `UnprocessableEntityException` | 422         |
| Unauthorized access          | `UnauthorizedException`        | 401         |
| Forbidden action             | `ForbiddenException`           | 403         |
| Database errors              | Let bubble → Global Filter     | 500         |

---

## Service Layer Rules

### ✅ DO Throw Exceptions For:

- **Missing resources**: `throw new NotFoundException('Venue not found')`
- **Validation failures**: `throw new BadRequestException('Batch too large')`
- **Business rules**: `throw new ConflictException('Seat already booked')`

### ❌ DON'T Catch-and-Rethrow:

```typescript
// ❌ Bad - pointless catch
try {
  return await this.repository.save(entity);
} catch (error) {
  throw error; // Why catch at all?
}

// ✅ Good - let it bubble
return await this.repository.save(entity);
```

### ✅ DO Catch For Translation:

```typescript
// ✅ Good - translating DB error to domain error
try {
  return await this.repository.save(entity);
} catch (error) {
  return handleDatabaseError(error, {
    messageOverrides: {
      [POSTGRES_ERROR_CODES.UNIQUE_VIOLATION]: 'Seat already exists',
    },
  });
}
```

---

## Database Error Handling Pattern

Use the `handleDatabaseError` utility for TypeORM errors:

```typescript
// In service
private async saveWithErrorHandling(entity: Seat): Promise<Seat> {
  try {
    return await this.seatRepository.save(entity);
  } catch (error) {
    return handleDatabaseError(error, {
      messageOverrides: {
        [POSTGRES_ERROR_CODES.UNIQUE_VIOLATION]:
          SEAT_ERROR_MESSAGES.UNIQUE_CONSTRAINT_VIOLATION,
        [POSTGRES_ERROR_CODES.FOREIGN_KEY_VIOLATION]:
          SEAT_ERROR_MESSAGES.VENUE_NOT_FOUND,
      },
      context: SeatsService.name,
    });
  }
}
```

### Postgres Error Codes Reference

| Code    | Name                  | Maps To               |
| ------- | --------------------- | --------------------- |
| `23505` | Unique violation      | `ConflictException`   |
| `23503` | Foreign key violation | `NotFoundException`   |
| `23502` | Not null violation    | `BadRequestException` |
| `23514` | Check constraint      | `BadRequestException` |

---

## Error Message Guidelines

### Include Context

```typescript
// ✅ Good - actionable message
throw new NotFoundException(`Venue with ID '${id}' not found`);

// ❌ Bad - generic
throw new NotFoundException('Not found');
```

### Use Constants for Repeated Messages

```typescript
// constants/seat-messages.ts
export const SEAT_ERROR_MESSAGES = {
  VENUE_NOT_FOUND: (id: string) => `Venue '${id}' not found`,
  BATCH_TOO_LARGE: (max: number) => `Batch exceeds maximum of ${max} seats`,
} as const;
```

### Never Expose Internal Details

```typescript
// ✅ Good - user-friendly
throw new ConflictException('A seat with this position already exists');

// ❌ Bad - exposes DB schema
throw new ConflictException('unique_seat_per_venue constraint violated');
```

---

## Global Exception Filter

For unhandled errors, implement a global filter:

```typescript
@Catch()
export class GlobalExceptionFilter implements ExceptionFilter {
  catch(exception: unknown, host: ArgumentsHost) {
    const ctx = host.switchToHttp();
    const response = ctx.getResponse<Response>();

    // Log the full error for debugging
    this.logger.error(exception);

    // Return sanitized response
    if (exception instanceof HttpException) {
      return response
        .status(exception.getStatus())
        .json(exception.getResponse());
    }

    // Unknown errors → 500
    return response.status(500).json({
      statusCode: 500,
      message: 'Internal server error',
    });
  }
}
```

---

## Transaction Error Handling

For transactional operations:

```typescript
async createBooking(dto: CreateBookingDto): Promise<Booking> {
  return this.dataSource.transaction(async (manager) => {
    // If ANY operation fails, entire transaction rolls back
    const tickets = await manager.find(Ticket, { where: { id: In(dto.ticketIds) } });

    if (tickets.length !== dto.ticketIds.length) {
      throw new NotFoundException('One or more tickets not found');
    }

    // Check ticket availability
    const unavailable = tickets.filter((t) => t.status !== TicketStatus.Available);

    if (unavailable.length > 0) {
      throw new ConflictException('Some tickets are no longer available');
    }

    // Book tickets...
  });
}
```

---

## Error Response Format

All errors should follow this structure:

```json
{
  "statusCode": 404,
  "message": "Venue with ID 'abc-123' not found",
  "error": "Not Found",
  "timestamp": "2024-01-15T10:30:00.000Z",
  "path": "/api/venues/abc-123"
}
```
