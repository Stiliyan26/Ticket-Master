---
description: Step-by-step implementation roadmap for Ticket Master. Update checkboxes as you complete each task.
alwaysApply: true
---

# Implementation Roadmap: Ticket Master

**Goal**: Mid-level ‚Üí Distributed Systems Engineer by **Jan 5th**
**Focus**: Backend first ‚Üí Angular later
**Progress**: Phase 1/7 Complete ‚úÖ | Foundation SOLID | Ready for DTOs

---

## Phase 1: Foundation ‚úÖ COMPLETED

**Objective**: Build a "Safe" schema that rejects bad data before it enters the system.

**üéâ Achievement**: Production-ready entity model with relationships, constraints, and concurrency control!

**üèÜ Key Learnings:**

- TypeORM entity relationships & constraints
- Optimistic locking for concurrency control
- DRY patterns with BaseEntity inheritance
- Type-safe constraint validation with keyof
- Dynamic modules for dependency management
- NestJS module loading patterns

### ‚úÖ Completed

- [x] Project setup with NX monorepo
- [x] DatabaseModule with TypeORM + PostgreSQL
- [x] ConfigModule with Zod validation
- [x] Entity design discussion (Assigned Seating model)

### ‚úÖ COMPLETED - All Entities with Advanced Features

- [x] **Venue entity** - id, name, address + @OneToMany(Seat, Event) + Unique(name)
- [x] **Seat entity** - id, section, row, number + @ManyToOne(Venue) + Unique(venue,section,row,number)
- [x] **Event entity** - id, name, date, basePrice, status(enum) + @ManyToOne(Venue)
- [x] **Ticket entity** - id, status(enum), price, version(@VersionColumn) + @ManyToOne(Event,Seat,Booking) + Unique(event,seat)
- [x] **Booking entity** - id, userId, totalPrice, status(enum) + @OneToMany(Ticket)

#### üèóÔ∏è Advanced Architecture Implemented:

- [x] **BaseEntity** - DRY pattern for id, createdAt, updatedAt
- [x] **Type-Safe Constraints** - keyof pattern prevents runtime errors
- [x] **Dynamic Modules** - forRoot() pattern with dependency management
- [x] **Bidirectional Relationships** - All entities properly linked
- [x] **Optimistic Locking** - @VersionColumn on Ticket for concurrency control
- [x] **Enum Types** - TypeScript enums mapped to DB enums

### üìã Up Next - DTOs & Validation

- [ ] **CreateVenueDto** - Validation decorators
- [ ] **CreateSeatDto** - Validation decorators
- [ ] **CreateEventDto** - Validation decorators (+ pre-generate tickets logic)
- [ ] **CreateBookingDto** - Validation decorators

### üìã Then - Services & Business Logic

- [ ] **VenueService** - CRUD for venues
- [ ] **SeatService** - CRUD for seats (bulk create for venue)
- [ ] **EventService** - CRUD + **pre-generate tickets on create**
- [ ] **TicketService** - Status transitions (AVAILABLE ‚Üí HELD ‚Üí SOLD)
- [ ] **BookingService** - Transaction logic (hold tickets + create booking)

### üìã Finally - Tests & Constraints

- [ ] **E2E Tests** - Verify booking prevents overselling
- [ ] **DB Constraints** - Unique(event, seat) on Ticket

---

## Phase 2: DTOs & Validation (CURRENT)

**Objective**: Move locking from DB to Redis for high-traffic scenarios.

- [ ] Docker Compose with Redis
- [ ] Redis Custom Provider (Factory pattern)
- [ ] Redlock implementation (acquire/release pattern)
- [ ] `@DistributedLock()` decorator
- [ ] Strategy pattern: Switch between DB lock & Redis lock
- [ ] Load testing with Artillery/k6

---

## Phase 3: Resilience

**Objective**: Handle failures gracefully without data corruption.

- [ ] Global Exception Filter
- [ ] Idempotency Keys (prevent double-booking on retry)
- [ ] Circuit Breaker pattern (for external services)
- [ ] Retry with exponential backoff
- [ ] Logging Interceptor (structured logs)
- [ ] Health checks endpoint
- [ ] Background job: Expire HELD tickets after timeout

---

## Phase 4: Async Consistency

**Objective**: Decouple operations and ensure eventual consistency.

- [ ] BullMQ setup with Redis
- [ ] Transactional Outbox pattern
- [ ] Event-driven booking confirmation (email queue)
- [ ] Dead letter queue handling

---

## Phase 5: API Polish & Documentation

**Objective**: Production-ready API surface.

- [ ] Swagger/OpenAPI documentation
- [ ] Rate limiting
- [ ] API versioning
- [ ] Request validation pipes (global)
- [ ] Response serialization interceptor

---

## Phase 6: Angular Frontend (Later)

**Objective**: Build UI to visualize the booking flow.

- [ ] Event listing page
- [ ] Seat map visualization
- [ ] Real-time ticket availability (WebSockets?)
- [ ] Booking flow with loading states
- [ ] Error handling UI
- [ ] Optimistic UI updates

---

## Phase 7: Microservices (Stretch Goal)

**Objective**: Split monolith into distributed services for true Trading212-like architecture.

- [ ] **Service Split**:
  - `ticket-service` - Inventory management (Tickets, Events, Venues)
  - `booking-service` - Booking orchestration
  - `payment-service` - Payment processing (mock)
  - `notification-service` - Email/SMS notifications
- [ ] **Inter-service Communication**:
  - Message broker (RabbitMQ or NATS)
  - gRPC or REST for sync calls
- [ ] **Saga Pattern** - Orchestrate multi-service bookings with compensating transactions
- [ ] **API Gateway** - Single entry point, routing, auth
- [ ] **Service Discovery** - (Optional) Consul or built-in
- [ ] **Docker Compose** - Run all services locally
- [ ] **Kubernetes** - (Optional) Deploy to K8s cluster

---

## Architecture Decisions Log

| Decision             | Choice                               | Reason                                              |
| -------------------- | ------------------------------------ | --------------------------------------------------- |
| Seating model        | Assigned Seating                     | Better for learning distributed locks               |
| Ticket creation      | Pre-generate on Event create         | Simpler locking, avoid INSERT race conditions       |
| Ticket timeout       | Background job                       | Don't slow down reads with timestamp checks         |
| Optimistic lock      | `@VersionColumn` on Ticket           | Ticket is the unit of contention                    |
| Entity inheritance   | BaseEntity with common fields        | DRY principle, consistent timestamps                |
| Constraint safety    | keyof type validation                | Compile-time error prevention                       |
| Module pattern       | Dynamic modules (forRoot)            | Learning advanced NestJS patterns                   |
| Relationship loading | Explicit import ordering             | Solve TypeORM entity resolution                     |
| Saga pattern         | Phase 7 (Microservices)              | Sagas need multiple DBs; monolith uses transactions |
| Architecture         | Monolith first ‚Üí Microservices later | Complete working system before splitting            |

---

## Quick Reference: What NestJS Patterns to Use Where

| Feature          | NestJS Pattern                     | Course Reference           |
| ---------------- | ---------------------------------- | -------------------------- |
| BookingService   | `@InjectRepository` + Transactions | Section 3: TypeORM         |
| Redis Provider   | Factory Provider + `useFactory`    | Section 4: DI              |
| DistributedLock  | Custom Decorator + Interceptor     | Section 6: Building Blocks |
| Config           | `registerAs` + `ConfigType`        | Section 5: Configuration   |
| Exception Filter | `@Catch()` + `ExceptionFilter`     | Section 6: Building Blocks |
| Logging          | Interceptor + `tap()`              | Section 6: Building Blocks |
