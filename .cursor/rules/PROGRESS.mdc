---
description: Step-by-step implementation roadmap for Ticket Master. Update checkboxes as you complete each task.
alwaysApply: true
---

# Implementation Roadmap: Ticket Master

**Goal**: Mid-level â†’ Distributed Systems Engineer by **Jan 5th**
**Focus**: Backend first â†’ Angular later
**Progress**: Phase 1/7 Complete âœ… | DTOs & Validation Complete âœ… | Ready for Services | Backend First â†’ Angular Last

---

## Phase 1: Foundation âœ… COMPLETED

**Objective**: Build a "Safe" schema that rejects bad data before it enters the system.

**ðŸŽ‰ Achievement**: Production-ready entity model with relationships, constraints, and concurrency control!

**ðŸ† Key Learnings:**

- TypeORM entity relationships & constraints
- Optimistic locking for concurrency control
- DRY patterns with BaseEntity inheritance
- Type-safe constraint validation with keyof
- Dynamic modules for dependency management
- NestJS module loading patterns

### âœ… Completed

- [x] Project setup with NX monorepo
- [x] DatabaseModule with TypeORM + PostgreSQL
- [x] ConfigModule with Zod validation
- [x] Entity design discussion (Assigned Seating model)

### âœ… COMPLETED - All Entities with Advanced Features

- [x] **Venue entity** - id, name, address + @OneToMany(Seat, Event) + Unique(name)
- [x] **Seat entity** - id, section, row, number + @ManyToOne(Venue) + Unique(venue,section,row,number)
- [x] **Event entity** - id, name, date, basePrice, status(enum) + @ManyToOne(Venue)
- [x] **Ticket entity** - id, status(enum), price, version(@VersionColumn) + @ManyToOne(Event,Seat,Booking) + Unique(event,seat)
- [x] **Booking entity** - id, userId, totalPrice, status(enum) + @OneToMany(Ticket)

#### ðŸ—ï¸ Advanced Architecture Implemented:

- [x] **BaseEntity** - DRY pattern for id, createdAt, updatedAt
- [x] **Type-Safe Constraints** - keyof pattern prevents runtime errors
- [x] **Dynamic Modules** - forRoot() pattern with dependency management
- [x] **Bidirectional Relationships** - All entities properly linked
- [x] **Optimistic Locking** - @VersionColumn on Ticket for concurrency control
- [x] **Enum Types** - TypeScript enums mapped to DB enums

### âœ… COMPLETED - DTOs & Validation

- [x] **Global ValidationPipe** - Configured in main.ts (whitelist, forbidNonWhitelisted, transform)
- [x] **CreateVenueDto** - Validation decorators (@IsString, @IsNotEmpty)
- [x] **UpdateVenueDto** - Uses PartialType(CreateVenueDto)
- [x] **CreateEventDto** - Validation decorators (name, date, basePrice, venueId) + @IsDateString, @Type(() => Number), @IsUUID(4)
- [x] **UpdateEventDto** - Uses PartialType(CreateEventDto)
- [x] **CreateSeatDto** - Validation decorators (section, row, number, venueId) + @Type(() => Number), @IsUUID(4)
- [x] **UpdateSeatDto** - Uses PartialType(CreateSeatDto)
- [x] **CreateBookingDto** - Validation decorators (userId, ticketIds array) + @IsUUID(4), @IsArray, @ArrayMinSize(1)
- [x] **UpdateBookingDto** - Uses PartialType(CreateBookingDto)

#### ðŸ† Key Learnings:

- Global ValidationPipe configuration (whitelist, forbidNonWhitelisted, transform)
- Type conversion with @Type(() => Number) for number fields
- Array validation with { each: true } for UUID arrays
- UUID v4 validation consistency (@IsUUID(4))
- PartialType pattern for UpdateDTOs
- Decorator execution order (transformation â†’ validation)

### ðŸ“‹ Next - Services & Business Logic (CURRENT)

- [ ] **VenueService** - CRUD for venues
- [ ] **SeatService** - CRUD for seats (bulk create for venue)
- [ ] **EventService** - CRUD + **pre-generate tickets on create**
- [ ] **TicketService** - Status transitions (AVAILABLE â†’ HELD â†’ SOLD)
- [ ] **BookingService** - Transaction logic (hold tickets + create booking)

### ðŸ“‹ After Services - Production Infrastructure

- [ ] **GlobalExceptionFilter** - Standardize all error responses
- [ ] **TransformInterceptor** - Wrap responses in `{ data: ... }`
- [ ] **LoggingInterceptor** - Request/response logging with correlation IDs
- [ ] **TimeoutInterceptor** - Kill long-running requests
- [ ] **CorrelationIdMiddleware** - Request tracing

### ðŸ“‹ Finally - Tests & Constraints

- [ ] **E2E Tests** - Verify booking prevents overselling
- [ ] **DB Constraints** - Unique(event, seat) on Ticket

---

## Phase 2: Distributed Locking

**Objective**: Move locking from DB to Redis for high-traffic scenarios.

- [ ] Docker Compose with Redis
- [ ] Redis Custom Provider (Factory pattern)
- [ ] Redlock implementation (acquire/release pattern)
- [ ] `@DistributedLock()` decorator
- [ ] Strategy pattern: Switch between DB lock & Redis lock
- [ ] Load testing with Artillery/k6

---

## Phase 3: Resilience

**Objective**: Handle failures gracefully without data corruption.

- [ ] Idempotency Keys (prevent double-booking on retry)
- [ ] Circuit Breaker pattern (for external services)
- [ ] Retry with exponential backoff
- [ ] Health checks endpoint
- [ ] Background job: Expire HELD tickets after timeout
- [ ] Rate limiting with @nestjs/throttler

---

## Phase 4: Async Consistency

**Objective**: Decouple operations and ensure eventual consistency within the monolith.

**Note**: Outbox pattern and event-driven architecture can be implemented in a monolith using message queues (BullMQ/RabbitMQ). Microservices are NOT required for these patterns - they can be added later when splitting services.

- [ ] BullMQ setup with Redis
- [ ] Transactional Outbox pattern (monolith - single DB)
- [ ] Event-driven booking confirmation (email queue)
- [ ] Dead letter queue handling

---

## Phase 5: API Polish & Documentation

**Objective**: Production-ready API surface.

- [ ] Swagger/OpenAPI documentation
- [ ] API versioning
- [ ] Request validation pipes (global)
- [ ] Response serialization interceptor

---

## Phase 6: Microservices

**Objective**: Split monolith into distributed services for true Trading212-like architecture.

**Note**: Complete all backend phases (1-5) before splitting into microservices. This phase comes before Angular to ensure all backend work is done first.

- [ ] **Service Split**:
  - `ticket-service` - Inventory management (Tickets, Events, Venues)
  - `booking-service` - Booking orchestration
  - `payment-service` - Payment processing (mock)
  - `notification-service` - Email/SMS notifications
- [ ] **Inter-service Communication**:
  - Message broker (RabbitMQ or NATS)
  - gRPC or REST for sync calls
- [ ] **Saga Pattern** - Orchestrate multi-service bookings with compensating transactions
- [ ] **API Gateway** - Single entry point, routing, auth
- [ ] **Service Discovery** - (Optional) Consul or built-in
- [ ] **Docker Compose** - Run all services locally
- [ ] **Kubernetes** - (Optional) Deploy to K8s cluster

---

## Phase 7: Angular Frontend

**Objective**: Build UI to visualize the booking flow.

**Note**: All backend work (Phases 1-6) should be complete before starting the Angular frontend.

- [ ] Event listing page
- [ ] Seat map visualization
- [ ] Real-time ticket availability (WebSockets?)
- [ ] Booking flow with loading states
- [ ] Error handling UI
- [ ] Optimistic UI updates

---

## Architecture Decisions Log

| Decision             | Choice                                   | Reason                                              |
| -------------------- | ---------------------------------------- | --------------------------------------------------- |
| Seating model        | Assigned Seating                         | Better for learning distributed locks               |
| Ticket creation      | Pre-generate on Event create             | Simpler locking, avoid INSERT race conditions       |
| Ticket timeout       | Background job                           | Don't slow down reads with timestamp checks         |
| Optimistic lock      | `@VersionColumn` on Ticket               | Ticket is the unit of contention                    |
| Entity inheritance   | BaseEntity with common fields            | DRY principle, consistent timestamps                |
| Constraint safety    | keyof type validation                    | Compile-time error prevention                       |
| Module pattern       | Dynamic modules (forRoot)                | Learning advanced NestJS patterns                   |
| Relationship loading | Explicit import ordering                 | Solve TypeORM entity resolution                     |
| Saga pattern         | Phase 6 (Microservices)                  | Sagas need multiple DBs; monolith uses transactions |
| Architecture         | Monolith first â†’ Microservices â†’ Angular | Complete backend before frontend                    |
| Outbox pattern       | Phase 4 (Monolith)                       | Can be done in monolith, no microservices required  |
| Folder structure     | Domain modules under `app/domains`       | Separate domain code from infrastructure            |
| UUID validation      | @IsUUID(4) consistently                  | Matches TypeORM's @PrimaryGeneratedColumn('uuid')   |
| Number validation    | @Type(() => Number) + @IsPositive()      | Handles HTTP string â†’ number conversion             |
| Array validation     | @IsUUID(4, { each: true })               | Validates each element in array                     |
| Infrastructure       | After services, before Phase 2           | Foundation for all future code                      |

---

## Quick Reference: What NestJS Patterns to Use Where

| Feature          | NestJS Pattern                     | Course Reference           |
| ---------------- | ---------------------------------- | -------------------------- |
| BookingService   | `@InjectRepository` + Transactions | Section 3: TypeORM         |
| Redis Provider   | Factory Provider + `useFactory`    | Section 4: DI              |
| DistributedLock  | Custom Decorator + Interceptor     | Section 6: Building Blocks |
| Config           | `registerAs` + `ConfigType`        | Section 5: Configuration   |
| Exception Filter | `@Catch()` + `ExceptionFilter`     | Section 6: Building Blocks |
| Logging          | Interceptor + `tap()`              | Section 6: Building Blocks |
