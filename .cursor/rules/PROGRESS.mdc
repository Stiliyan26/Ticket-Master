---
description: Step-by-step implementation roadmap for Ticket Master. Update checkboxes as you complete each task.
alwaysApply: false
---

# Implementation Roadmap: Ticket Master

**Goal**: Mid-level ‚Üí Distributed Systems Engineer by **Jan 5th**
**Focus**: Backend first ‚Üí Angular later
**Progress**: Phase 1B ‚úÖ COMPLETED | Ready for Phase 2 (Distributed Locking)

---

## üö® RULES FOR AI ASSISTANTS

> **CRITICAL**: Follow these rules to prevent scope creep and ensure predictable work.

1. **ONLY implement what is explicitly listed** in the current phase's checklist
2. **DO NOT add endpoints, methods, or features** not listed in the tasks
3. **DO NOT refactor existing code** unless the task explicitly says "refactor"
4. **DO NOT add "nice to have" improvements** - stick to the spec
5. **Mark tasks complete** as you finish them
6. **If something seems missing**, ask the user before adding it
7. **Controllers are THIN** - they only call service methods, no business logic

---

## Phase 1: Foundation ‚úÖ COMPLETED

**Objective**: Build a "Safe" schema that rejects bad data before it enters the system.

**üéâ Achievement**: Production-ready entity model with relationships, constraints, and concurrency control!

**üèÜ Key Learnings:**

- TypeORM entity relationships & constraints
- Optimistic locking for concurrency control
- DRY patterns with BaseEntity inheritance
- Type-safe constraint validation with keyof
- Dynamic modules for dependency management
- NestJS module loading patterns

### ‚úÖ Completed

- [x] Project setup with NX monorepo
- [x] DatabaseModule with TypeORM + PostgreSQL
- [x] ConfigModule with Zod validation
- [x] Entity design discussion (Assigned Seating model)

### ‚úÖ COMPLETED - All Entities with Advanced Features

- [x] **Venue entity** - id, name, address + @OneToMany(Seat, Event) + Unique(name)
- [x] **Seat entity** - id, section, row, number + @ManyToOne(Venue) + Unique(venue,section,row,number)
- [x] **Event entity** - id, name, date, basePrice, status(enum) + @ManyToOne(Venue)
- [x] **Ticket entity** - id, status(enum), price, version(@VersionColumn) + @ManyToOne(Event,Seat,Booking) + Unique(event,seat)
- [x] **Booking entity** - id, userId, totalPrice, status(enum) + @OneToMany(Ticket)

#### üèóÔ∏è Advanced Architecture Implemented:

- [x] **BaseEntity** - DRY pattern for id, createdAt, updatedAt
- [x] **Type-Safe Constraints** - keyof pattern prevents runtime errors
- [x] **Dynamic Modules** - forRoot() pattern with dependency management
- [x] **Bidirectional Relationships** - All entities properly linked
- [x] **Optimistic Locking** - @VersionColumn on Ticket for concurrency control
- [x] **Enum Types** - TypeScript enums mapped to DB enums

### ‚úÖ COMPLETED - DTOs & Validation

- [x] **Global ValidationPipe** - Configured in main.ts (whitelist, forbidNonWhitelisted, transform)
- [x] **CreateVenueDto** - Validation decorators (@IsString, @IsNotEmpty)
- [x] **UpdateVenueDto** - Uses PartialType(CreateVenueDto)
- [x] **CreateEventDto** - Validation decorators (name, date, basePrice, venueId) + @IsDateString, @Type(() => Number), @IsUUID(4)
- [x] **UpdateEventDto** - Uses PartialType(CreateEventDto)
- [x] **CreateSeatDto** - Validation decorators (section, row, number, venueId) + @Type(() => Number), @IsUUID(4)
- [x] **UpdateSeatDto** - Uses PartialType(CreateSeatDto)
- [x] **CreateBookingDto** - Validation decorators (userId, ticketIds array) + @IsUUID(4), @IsArray, @ArrayMinSize(1)
- [x] **UpdateBookingDto** - Uses PartialType(CreateBookingDto)

#### üèÜ Key Learnings:

- Global ValidationPipe configuration (whitelist, forbidNonWhitelisted, transform)
- Type conversion with @Type(() => Number) for number fields
- Array validation with { each: true } for UUID arrays
- UUID v4 validation consistency (@IsUUID(4))
- PartialType pattern for UpdateDTOs
- Decorator execution order (transformation ‚Üí validation)

### ‚úÖ COMPLETED - Services & Business Logic

- [x] **VenueService** - CRUD for venues + `findByIds()` for bulk lookup
- [x] **SeatService** - CRUD with bulk transactional create + pagination
- [x] **EventsService** - CRUD with ticket auto-generation on create
- [x] **TicketsService** - `createTicketsForEvent()`, `findByEvent()`, `removeTicketsByEvent()`, `updatePricesByEvent()`, `hasSoldTickets()`
- [x] **@Transactional() decorator** - Custom decorator with AsyncLocalStorage for nested transactions
- [x] **pagination.util.ts** - Generic paginated response utility
- [x] **database-error.util.ts** - Enhanced with `createEntityMessageOverrides()` helper

#### üèÜ Services Key Learnings:

- AsyncLocalStorage for transaction propagation (nested transaction support)
- Repository manager swapping via Object.defineProperty (TypeORM hack)
- Generic pagination with deterministic ordering (venue ‚Üí section ‚Üí row ‚Üí number)
- Batch validation patterns (empty check, max size constants)
- Map-based lookups for O(1) venue resolution in bulk operations
- Separation of concerns: validation ‚Üí lookup ‚Üí mapping ‚Üí save

### ‚úÖ COMPLETED - Generic Repository Layer

- [x] **BaseRepository** - Abstract class with common CRUD operations (`create`, `save`, `findById`, `findOne`, `findMany`, `findWithPagination`, `count`, `exists`, `update`, `merge`, `remove`, `delete`, `softDelete`, `restore`)
- [x] **repository.types.ts** - Type-safe query options (`FindOneOptions`, `FindManyOptions`, `PaginationOptions`, `PaginatedResult`)
- [x] **repository.provider.ts** - NestJS DI factory (`createRepositoryProvider`, `createRepositoryProviders`)
- [x] **VenueRepository** - Example concrete implementation with domain-specific methods
- [x] **@Transactional compatibility** - Updated decorator to work with both `Repository` and `BaseRepository`

#### üèÜ Repository Layer Key Learnings:

- Repository pattern abstracts TypeORM details from services
- Generic base class with type-safe operations for any entity
- Factory provider pattern for NestJS DI integration
- `instanceof` checks for both raw `Repository` and `BaseRepository` wrapper
- Concrete repositories extend base with domain-specific queries

---

## üìã Phase 1B: Complete Ticket & Booking Domains ‚úÖ COMPLETED

**Objective**: Complete the core business engine with strict domain boundaries.

**üéâ Achievement**: Full booking flow with ticket hold/release/purchase, production-grade error handling!

### üé´ Task 1: TicketsService - Hold/Release/Finalize Methods

**File**: `apps/api/src/app/domains/tickets/tickets.service.ts`

Add these **exact** methods to the existing TicketsService:

#### 1.1 `holdTickets(ticketIds: string[]): Promise<Ticket[]>`

```typescript
// Signature
async holdTickets(ticketIds: string[]): Promise<Ticket[]>

// Behavior:
// 1. Find tickets by IDs with pessimistic write lock (SELECT FOR UPDATE)
// 2. Validate ALL tickets are AVAILABLE status
// 3. If any not available ‚Üí throw ConflictException('One or more tickets are no longer available')
// 4. Update status to HELD, set heldAt = new Date()
// 5. Save and return updated tickets
// 6. Use @Transactional decorator

// Required imports: ConflictException
// Uses optimistic locking via @VersionColumn (already on entity)
```

#### 1.2 `releaseTickets(ticketIds: string[]): Promise<void>`

```typescript
// Signature
async releaseTickets(ticketIds: string[]): Promise<void>

// Behavior:
// 1. Find tickets by IDs
// 2. Filter to only HELD tickets (ignore others silently)
// 3. Update status to AVAILABLE, clear heldAt = null
// 4. Save changes
// 5. Use @Transactional decorator
```

#### 1.3 `finalizePurchase(ticketIds: string[]): Promise<Ticket[]>`

```typescript
// Signature
async finalizePurchase(ticketIds: string[]): Promise<Ticket[]>

// Behavior:
// 1. Find tickets by IDs
// 2. Validate ALL tickets are HELD status
// 3. If any not HELD ‚Üí throw ConflictException('Tickets must be held before purchase')
// 4. Update status to SOLD
// 5. Save and return updated tickets
// 6. Use @Transactional decorator
```

#### 1.4 Entity Change Required

**File**: `apps/api/src/app/domains/tickets/entities/ticket.entity.ts`

Add `heldAt` column:

```typescript
@Column({ type: 'timestamp', nullable: true })
heldAt: Date | null;
```

- [x] **Add `heldAt` column to Ticket entity**
- [x] **Implement `holdTickets()` method**
- [x] **Implement `releaseTickets()` method**
- [x] **Implement `finalizePurchase()` method**

---

### üé´ Task 2: TicketsController - Final API Shape

**File**: `apps/api/src/app/domains/tickets/tickets.controller.ts`

**FINAL ENDPOINTS** (no more, no less):

| Method | Path                                | Description                 | Service Method     |
| ------ | ----------------------------------- | --------------------------- | ------------------ |
| GET    | `/tickets/event/:eventId`           | Get all tickets for event   | `findByEvent()`    |
| GET    | `/tickets/event/:eventId/available` | Get available tickets count | `countAvailable()` |

**DO NOT ADD**: POST, PATCH, DELETE endpoints. Tickets are managed via Events and Bookings.

#### 2.1 Add `countAvailable()` to TicketsService

```typescript
// Signature
async countAvailable(eventId: string): Promise<{ available: number; total: number }>

// Behavior:
// 1. Count tickets where event.id = eventId AND status = AVAILABLE
// 2. Count total tickets for event
// 3. Return { available, total }
```

#### 2.2 Add endpoint to controller

```typescript
@Get('/event/:eventId/available')
@ApiOperation({ summary: 'Get available ticket count for an event' })
async getAvailability(@Param('eventId', ParseUUIDPipe) eventId: string) {
  return this.ticketsService.countAvailable(eventId);
}
```

- [x] **Add `countAvailable()` method to TicketsService**
- [x] **Add GET `/tickets/event/:eventId/available` endpoint**
- [x] **Verify controller has only 2 GET endpoints (no POST/PATCH/DELETE)**

---

### üõçÔ∏è Task 3: BookingsService - Create & Cancel

**File**: `apps/api/src/app/domains/bookings/bookings.service.ts`

**Replace the entire placeholder service** with real implementation:

#### 3.1 Dependencies

```typescript
constructor(
  @InjectRepository(Booking)
  public readonly bookingRepository: Repository<Booking>,
  private readonly ticketsService: TicketsService,
) {}
```

#### 3.2 `create(dto: CreateBookingDto): Promise<Booking>`

```typescript
// Signature
@Transactional<BookingsService>({ repoKey: 'bookingRepository', ... })
async create(dto: CreateBookingDto): Promise<Booking>

// Behavior:
// 1. Call ticketsService.holdTickets(dto.ticketIds) - this validates availability
// 2. Calculate totalPrice = sum of ticket prices
// 3. Create booking with status = CONFIRMED, userId, totalPrice
// 4. Assign tickets to booking (ticket.booking = savedBooking)
// 5. Call ticketsService.finalizePurchase(dto.ticketIds)
// 6. Return booking with tickets relation loaded

// On error: Transaction rolls back automatically (tickets released)
```

#### 3.3 `findById(id: string): Promise<Booking>`

```typescript
// Signature
async findById(id: string): Promise<Booking>

// Behavior:
// 1. Find booking by ID with relations: { tickets: { seat: true, event: true } }
// 2. If not found ‚Üí throw NotFoundException
// 3. Return booking
```

#### 3.4 `cancel(id: string): Promise<void>`

```typescript
// Signature
@Transactional<BookingsService>({ repoKey: 'bookingRepository', ... })
async cancel(id: string): Promise<void>

// Behavior:
// 1. Find booking by ID with tickets
// 2. If not found ‚Üí throw NotFoundException
// 3. If status already CANCELLED ‚Üí throw ConflictException('Booking already cancelled')
// 4. Get ticket IDs from booking.tickets
// 5. Call ticketsService.releaseTickets(ticketIds)
// 6. Update booking status to CANCELLED
// 7. Save booking
```

- [x] **Implement `create()` with ticket holding and purchase finalization**
- [x] **Implement `findById()` with proper relations**
- [x] **Implement `cancel()` with ticket release**
- [x] **Remove placeholder methods (`findAll`, `update`, `remove`)**

---

### üõçÔ∏è Task 4: BookingsController - Final API Shape

**File**: `apps/api/src/app/domains/bookings/bookings.controller.ts`

**FINAL ENDPOINTS** (no more, no less):

| Method | Path                   | Description          | Service Method |
| ------ | ---------------------- | -------------------- | -------------- |
| POST   | `/bookings`            | Create a new booking | `create()`     |
| GET    | `/bookings/:id`        | Get booking by ID    | `findById()`   |
| POST   | `/bookings/:id/cancel` | Cancel a booking     | `cancel()`     |

**REMOVE**: GET `/bookings` (findAll), PATCH `/bookings/:id`, DELETE `/bookings/:id`

#### 4.1 Final Controller Code

```typescript
@ApiTags('bookings')
@Controller('bookings')
export class BookingsController {
  constructor(private readonly bookingsService: BookingsService) {}

  @Post()
  @HttpCode(HttpStatus.CREATED)
  @ApiOperation({ summary: 'Create a new booking' })
  create(@Body() createBookingDto: CreateBookingDto) {
    return this.bookingsService.create(createBookingDto);
  }

  @Get(':id')
  @ApiOperation({ summary: 'Get a booking by id' })
  findOne(@Param('id', ParseUUIDPipe) id: string) {
    return this.bookingsService.findOne(id);
  }

  @Post(':id/cancel')
  @HttpCode(HttpStatus.OK)
  @ApiOperation({ summary: 'Cancel a booking' })
  cancel(@Param('id', ParseUUIDPipe) id: string) {
    return this.bookingsService.cancel(id);
  }
}
```

- [x] **Update controller to have exactly 3 endpoints**
- [x] **Remove findAll, update, remove methods and endpoints**
- [x] **Add POST `/bookings/:id/cancel` endpoint**

---

### ‚úÖ Task 6: Phase 1B Completion Checklist ‚úÖ VERIFIED

All items verified:

- [x] **TicketsService has 8 methods**: `createTicketsForEvent`, `findByEvent`, `removeTicketsByEvent`, `updatePricesByEvent`, `hasSoldTickets`, `holdTickets`, `releaseTickets`, `finalizePurchase`, `countAvailable`
- [x] **TicketsController has 2 GET endpoints only**
- [x] **BookingsService has 3 methods**: `create`, `findById`, `cancel`
- [x] **BookingsController has 3 endpoints**: POST `/`, GET `/:id`, POST `/:id/cancel`
- [x] **Ticket entity has `heldAt` column**

---

## Phase 2: Distributed Locking

**Objective**: Move locking from DB to Redis for high-traffic scenarios.

### Task 2.1: Docker & Redis Setup

**File**: `docker-compose.yml` (create in project root)

```yaml
version: '3.8'
services:
  redis:
    image: redis:7-alpine
    ports:
      - '6379:6379'
    volumes:
      - redis_data:/data
volumes:
  redis_data:
```

- [ ] **Create docker-compose.yml with Redis service**
- [ ] **Add `docker-compose up -d` to README**

### Task 2.2: Redis Module

**File**: `apps/api/src/app/redis/redis.module.ts`

```typescript
// Dynamic module with forRoot()
// Uses Factory Provider pattern (useFactory)
// Injects ConfigService for REDIS_URL
// Exports Redis client
```

**File**: `apps/api/src/app/redis/redis.provider.ts`

```typescript
// Factory provider that creates Redis client
// Uses ioredis package
// Handles connection errors gracefully
```

- [ ] **Install ioredis**: `npm install ioredis`
- [ ] **Create RedisModule with forRoot()**
- [ ] **Create Redis factory provider**
- [ ] **Add REDIS_URL to env.validation.ts**

### Task 2.3: Distributed Lock Service

**File**: `apps/api/src/app/common/services/distributed-lock.service.ts`

```typescript
// Methods:
// - acquireLock(key: string, ttlMs: number): Promise<string | null>
// - releaseLock(key: string, token: string): Promise<boolean>
// Uses SET NX EX pattern (not Redlock for simplicity)
// Returns lock token on success, null on failure
```

- [ ] **Create DistributedLockService**
- [ ] **Implement acquireLock with SET NX EX**
- [ ] **Implement releaseLock with Lua script**

### Task 2.4: @DistributedLock Decorator

**File**: `apps/api/src/app/common/decorators/distributed-lock/distributed-lock.decorator.ts`

```typescript
// Decorator options: { keyPrefix: string, ttlMs: number, paramIndex?: number }
// Works with Interceptor to acquire/release lock
// Key format: `${keyPrefix}:${paramValue}`
// Throws ConflictException if lock not acquired
```

**File**: `apps/api/src/app/common/interceptors/distributed-lock.interceptor.ts`

```typescript
// Reads metadata from @DistributedLock decorator
// Acquires lock before method execution
// Releases lock after method completes (success or error)
```

- [ ] **Create @DistributedLock decorator**
- [ ] **Create DistributedLockInterceptor**
- [ ] **Register interceptor globally or per-controller**

### Task 2.5: Apply to TicketsService

Update `holdTickets()` to use distributed lock:

```typescript
@DistributedLock({ keyPrefix: 'ticket-hold', ttlMs: 5000 })
async holdTickets(ticketIds: string[]): Promise<Ticket[]>
```

- [ ] **Add @DistributedLock to holdTickets()**
- [ ] **Test that concurrent holds for same tickets fail gracefully**

### Task 2.6: Load Testing

**File**: `load-tests/hold-tickets.yml` (Artillery config)

```yaml
# Test concurrent ticket holds
# 100 virtual users trying to hold same tickets
# Verify only 1 succeeds, others get 409
```

- [ ] **Install Artillery**: `npm install -D artillery`
- [ ] **Create load test config**
- [ ] **Run test and document results**

---

## Phase 3: Resilience

**Objective**: Handle failures gracefully without data corruption.

### Task 3.1: Idempotency Keys

**File**: `apps/api/src/app/common/decorators/idempotent/idempotent.decorator.ts`

```typescript
// Reads X-Idempotency-Key header
// Stores result in Redis with TTL (24 hours)
// Returns cached result if key exists
// Prevents double-booking on retry
```

**Apply to**: `BookingsController.create()`

- [ ] **Create @Idempotent decorator**
- [ ] **Create IdempotencyInterceptor**
- [ ] **Apply to POST /bookings**
- [ ] **Test: Same key returns same result, no duplicate booking**

### Task 3.2: Background Job - Expire Held Tickets

**File**: `apps/api/src/app/jobs/expire-held-tickets.job.ts`

```typescript
// Runs every 1 minute via @Cron
// Finds tickets where status = HELD AND heldAt < (now - 10 minutes)
// Releases them (status = AVAILABLE, heldAt = null)
// Logs count of expired tickets
```

- [ ] **Install @nestjs/schedule**: `npm install @nestjs/schedule`
- [ ] **Create ExpireHeldTicketsJob**
- [ ] **Register ScheduleModule in AppModule**
- [ ] **Test: Hold ticket, wait 10+ min, verify released**

### Task 3.3: Health Check Endpoint

**File**: `apps/api/src/app/health/health.controller.ts`

```typescript
// GET /health
// Checks: Database connection, Redis connection
// Returns: { status: 'ok' | 'error', checks: { db: 'up'|'down', redis: 'up'|'down' } }
```

- [ ] **Install @nestjs/terminus**: `npm install @nestjs/terminus`
- [ ] **Create HealthModule and HealthController**
- [ ] **Add DB and Redis health indicators**

### Task 3.4: Rate Limiting

**File**: Update `main.ts`

```typescript
// Apply ThrottlerGuard globally
// Config: 100 requests per 60 seconds per IP
// Returns 429 Too Many Requests when exceeded
```

- [ ] **Install @nestjs/throttler**: `npm install @nestjs/throttler`
- [ ] **Configure ThrottlerModule in AppModule**
- [ ] **Apply ThrottlerGuard globally**

### Task 3.5: Circuit Breaker

**File**: `apps/api/src/app/common/decorators/circuit-breaker/circuit-breaker.decorator.ts`

```typescript
// Decorator options: { failureThreshold: number, resetTimeoutMs: number }
// States: CLOSED (normal), OPEN (rejecting), HALF-OPEN (testing recovery)
// Uses Redis to track failure counts across instances
// Throws ServiceUnavailableException when OPEN
```

**File**: `apps/api/src/app/common/interceptors/circuit-breaker.interceptor.ts`

```typescript
// Intercepts calls to external services (payment, email)
// Tracks failures, opens circuit after threshold
// Half-open state allows periodic health checks
// Returns cached/fallback response when OPEN
```

**Apply to**: External service calls in queue processors (booking confirmation email)

- [ ] **Install opossum**: `npm install opossum`
- [ ] **Create CircuitBreakerService** (wraps opossum)
- [ ] **Create @CircuitBreaker decorator**
- [ ] **Create CircuitBreakerInterceptor**
- [ ] **Apply to booking confirmation email in queue processor**
- [ ] **Test: Trigger failures, verify circuit opens, verify fallback response**

---

## Phase 4: Async Consistency

**Objective**: Decouple operations and ensure eventual consistency.

### Task 4.1: BullMQ Setup

**File**: `apps/api/src/app/queues/queues.module.ts`

```typescript
// Configures BullMQ with Redis connection
// Exports BullModule for use in other modules
```

- [ ] **Install BullMQ**: `npm install @nestjs/bullmq bullmq`
- [ ] **Create QueuesModule**
- [ ] **Configure Redis connection**

### Task 4.2: Booking Confirmation Queue

**File**: `apps/api/src/app/queues/booking-confirmation.processor.ts`

```typescript
// Processor for 'booking-confirmation' queue
// Job data: { bookingId: string, userEmail: string }
// Action: Log "Sending confirmation email for booking {id} to {email}"
// (Actual email sending is out of scope - just log)
```

**Update**: `BookingsService.create()` to enqueue job after successful booking.

- [ ] **Create booking-confirmation queue**
- [ ] **Create BookingConfirmationProcessor**
- [ ] **Enqueue job in BookingsService.create()**

### Task 4.3: Transactional Outbox Pattern

**File**: `apps/api/src/app/common/entities/outbox-event.entity.ts`

```typescript
// Entity: id, eventType, payload (JSON), processedAt, createdAt
// Stores events that need to be published
```

**File**: `apps/api/src/app/jobs/process-outbox.job.ts`

```typescript
// Runs every 5 seconds
// Finds unprocessed events (processedAt = null)
// Publishes to queue
// Marks as processed
```

- [ ] **Create OutboxEvent entity**
- [ ] **Create ProcessOutboxJob**
- [ ] **Update BookingsService to write to outbox in same transaction**

### Task 4.4: Dead Letter Queue

**File**: `apps/api/src/app/queues/dead-letter.processor.ts`

```typescript
// Handles failed jobs after max retries
// Logs error details
// Could notify admin (out of scope - just log)
```

- [ ] **Configure DLQ in BullMQ**
- [ ] **Create DeadLetterProcessor**
- [ ] **Test: Force job failure, verify lands in DLQ**

---

## Phase 5: API Polish & Documentation

**Objective**: Production-ready API surface.

### Task 5.1: Swagger Setup

**File**: Update `main.ts`

```typescript
// Configure SwaggerModule
// Title: "Ticket Master API"
// Version: "1.0"
// Description: "Event ticketing system API"
// Add bearer auth (for future)
```

- [ ] **Install @nestjs/swagger**: `npm install @nestjs/swagger`
- [ ] **Configure SwaggerModule in main.ts**
- [ ] **Access docs at /api/docs**

### Task 5.2: Response DTOs

Create response DTOs for all entities to control serialization:

**Files**:

- `apps/api/src/app/domains/events/dto/event-response.dto.ts`
- `apps/api/src/app/domains/tickets/dto/ticket-response.dto.ts`
- `apps/api/src/app/domains/bookings/dto/booking-response.dto.ts`

```typescript
// Use @Exclude() to hide internal fields
// Use @Expose() to include computed fields
// Use @Type() for nested objects
```

- [ ] **Create EventResponseDto**
- [ ] **Create TicketResponseDto**
- [ ] **Create BookingResponseDto**
- [ ] **Apply ClassSerializerInterceptor globally**

### Task 5.3: API Versioning

**File**: Update `main.ts`

```typescript
// Enable URI versioning: /api/v1/...
// Default version: 1
// All controllers get @Version('1')
```

- [ ] **Configure versioning in main.ts**
- [ ] **Update all controllers with @Version('1')**
- [ ] **Update Swagger to show version**

---

## Phase 6: Microservices (Future)

**Objective**: Split monolith into distributed services.

> **Note**: This phase is optional and only if time permits. Complete Phases 1-5 first.

### Services to Extract:

1. **ticket-service** - Ticket inventory (Events, Venues, Seats, Tickets)
2. **booking-service** - Booking orchestration
3. **notification-service** - Email/SMS (mock)

### Tasks:

- [ ] Create separate NX apps for each service
- [ ] Set up RabbitMQ for inter-service communication
- [ ] Implement Saga pattern for distributed transactions
- [ ] Create API Gateway with routing
- [ ] Update docker-compose for all services

---

## Phase 7: Angular Frontend (Future)

**Objective**: Build UI to visualize the booking flow.

> **Note**: All backend work (Phases 1-5) should be complete first.

### Pages:

1. **Event List** - Browse events with pagination
2. **Event Detail** - See available seats
3. **Seat Selection** - Interactive seat map
4. **Checkout** - Booking confirmation

### Tasks:

- [ ] Set up Angular routing
- [ ] Create EventListComponent with pagination
- [ ] Create EventDetailComponent with seat availability
- [ ] Create SeatMapComponent (SVG-based)
- [ ] Create BookingCheckoutComponent
- [ ] Add loading states and error handling
- [ ] Connect to API with HttpClient

---

## Architecture Decisions Log

| Decision             | Choice                                   | Reason                                              |
| -------------------- | ---------------------------------------- | --------------------------------------------------- |
| Seating model        | Assigned Seating                         | Better for learning distributed locks               |
| Ticket creation      | Pre-generate on Event create             | Simpler locking, avoid INSERT race conditions       |
| Ticket timeout       | Background job                           | Don't slow down reads with timestamp checks         |
| Optimistic lock      | `@VersionColumn` on Ticket               | Ticket is the unit of contention                    |
| Entity inheritance   | BaseEntity with common fields            | DRY principle, consistent timestamps                |
| Constraint safety    | keyof type validation                    | Compile-time error prevention                       |
| Module pattern       | Dynamic modules (forRoot)                | Learning advanced NestJS patterns                   |
| Relationship loading | Explicit import ordering                 | Solve TypeORM entity resolution                     |
| Saga pattern         | Phase 6 (Microservices)                  | Sagas need multiple DBs; monolith uses transactions |
| Architecture         | Monolith first ‚Üí Microservices ‚Üí Angular | Complete backend before frontend                    |
| Outbox pattern       | Phase 4 (Monolith)                       | Can be done in monolith, no microservices required  |
| Folder structure     | Domain modules under `app/domains`       | Separate domain code from infrastructure            |
| UUID validation      | @IsUUID(4) consistently                  | Matches TypeORM's @PrimaryGeneratedColumn('uuid')   |
| Number validation    | @Type(() => Number) + @IsPositive()      | Handles HTTP string ‚Üí number conversion             |
| Array validation     | @IsUUID(4, { each: true })               | Validates each element in array                     |
| Infrastructure       | After services, before Phase 2           | Foundation for all future code                      |
| Transaction handling | Custom `@Transactional()` decorator      | Reusable, nesting via AsyncLocalStorage, repo swap  |
| Pagination           | Generic `paginate()` utility             | DRY pattern, consistent response format             |
| Error messages       | `createEntityMessageOverrides()`         | Type-safe, consistent DB error translations         |
| Booking cancel       | POST not DELETE                          | Cancel is an action, not deletion of resource       |
| Ticket endpoints     | GET only                                 | Tickets managed via Events/Bookings, not directly   |
| Repository layer     | Generic `BaseRepository<T>` + concrete   | Abstracts TypeORM, enables domain-specific queries  |
| Repo DI              | Factory provider with `DataSource`       | Clean injection of custom repositories in modules   |

---

## Quick Reference: What NestJS Patterns to Use Where

| Feature          | NestJS Pattern                     | Course Reference           |
| ---------------- | ---------------------------------- | -------------------------- |
| BookingService   | `@InjectRepository` + Transactions | Section 3: TypeORM         |
| Repository Layer | `BaseRepository<T>` + Factory      | Custom pattern             |
| Redis Provider   | Factory Provider + `useFactory`    | Section 4: DI              |
| DistributedLock  | Custom Decorator + Interceptor     | Section 6: Building Blocks |
| Config           | `registerAs` + `ConfigType`        | Section 5: Configuration   |
| Exception Filter | `@Catch()` + `ExceptionFilter`     | Section 6: Building Blocks |
| Scheduling       | `@Cron()` + ScheduleModule         | @nestjs/schedule docs      |
| Queues           | BullMQ + Processors                | @nestjs/bullmq docs        |

---

## API Endpoints Summary

### Final API Shape (After Phase 1B)

| Domain   | Method | Endpoint                          | Description             |
| -------- | ------ | --------------------------------- | ----------------------- |
| Events   | POST   | /events                           | Create event            |
| Events   | GET    | /events                           | List events (paginated) |
| Events   | GET    | /events/:id                       | Get event by ID         |
| Events   | PATCH  | /events/:id                       | Update event            |
| Events   | DELETE | /events/:id                       | Delete event            |
| Venues   | POST   | /venues                           | Create venue            |
| Venues   | GET    | /venues                           | List venues             |
| Venues   | GET    | /venues/:id                       | Get venue by ID         |
| Venues   | PATCH  | /venues/:id                       | Update venue            |
| Venues   | DELETE | /venues/:id                       | Delete venue            |
| Seats    | POST   | /seats                            | Create seat             |
| Seats    | POST   | /seats/bulk                       | Create seats in bulk    |
| Seats    | GET    | /seats                            | List seats (paginated)  |
| Seats    | GET    | /seats/:id                        | Get seat by ID          |
| Seats    | PATCH  | /seats/:id                        | Update seat             |
| Seats    | DELETE | /seats/:id                        | Delete seat             |
| Tickets  | GET    | /tickets/event/:eventId           | Get tickets for event   |
| Tickets  | GET    | /tickets/event/:eventId/available | Get availability count  |
| Bookings | POST   | /bookings                         | Create booking          |
| Bookings | GET    | /bookings/:id                     | Get booking by ID       |
| Bookings | POST   | /bookings/:id/cancel              | Cancel booking          |

**Total: 19 endpoints**
